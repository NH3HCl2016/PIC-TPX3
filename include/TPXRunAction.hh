//
// ********************************************************************
// * License and Disclaimer                                           *
// *                                                                  *
// * The  Geant4 software  is  copyright of the Copyright Holders  of *
// * the Geant4 Collaboration.  It is provided  under  the terms  and *
// * conditions of the Geant4 Software License,  included in the file *
// * LICENSE and available at  http://cern.ch/geant4/license .  These *
// * include a list of copyright holders.                             *
// *                                                                  *
// * Neither the authors of this software system, nor their employing *
// * institutes,nor the agencies providing financial support for this *
// * work  make  any representation or  warranty, express or implied, *
// * regarding  this  software system or assume any liability for its *
// * use.  Please see the license in the file  LICENSE  and URL above *
// * for the full disclaimer and the limitation of liability.         *
// *                                                                  *
// * This  code  implementation is the result of  the  scientific and *
// * technical work of the GEANT4 collaboration.                      *
// * By using,  copying,  modifying or  distributing the software (or *
// * any work based  on the software)  you  agree  to acknowledge its *
// * use  in  resulting  scientific  publications,  and indicate your *
// * acceptance of all terms of the Geant4 Software license.          *
// ********************************************************************
//
//
/// \file TPXRunAction.hh
/// \brief Definition of the TPXRunAction class

#ifndef TPXRunAction_h
#define TPXRunAction_h 1

#include "G4UserRunAction.hh"
#include "G4VUserPhysicsList.hh"
#include "G4Run.hh"
#include "G4AccumulableManager.hh"
#include "G4LogicalVolumeStore.hh"
#include "G4LogicalVolume.hh"
#include "G4UnitsTable.hh"
#include "G4Accumulable.hh"
#include "G4EmCalculator.hh"
#include "G4ParticleDefinition.hh"
#include "G4ParticleTable.hh"
#include "G4NistManager.hh"
#include "globals.hh"
#ifdef TPXMT
#include "G4MTRunManager.hh"
#else
#include "G4RunManager.hh"
#endif

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wshadow"
#include <TH1D.h>
#include <TH3D.h>
#include <TFile.h>
#include <TTree.h>
#pragma GCC diagnostic pop

#include "TPXDetectorConstruction.hh"
#include "ChargeTransport.hh"

class G4Run;

// User-defined run action management class, including the definition of the limitations to the ionized electron bunches, histograms of energy and polarization, and other run-level actions
class TPXRunAction: public G4UserRunAction {
public:
    TPXRunAction();
    virtual ~TPXRunAction();

    // virtual G4Run *GenerateRun();
    virtual void BeginOfRunAction(const G4Run *run) override;
    virtual void EndOfRunAction(const G4Run *run) override;
    /**
     * @brief Get the total number of events in the current run
     * @return Total number of events
     */
    G4int GetTotalEventNumber() {
        return totalEventNumber;
    }
    /**
     * @brief Get the maximum number of electrons per charge carrier bunch (cluster) generated by ionization
     * @return Maximum number of electrons per charge carrier bunch
     */
    inline G4double GetEPC() const {
        return electronPerBunch;
    }
    /**
     * @brief Get the charge transport handler
     * @return Pointer to the charge transport handler
     */
    inline ChargeTransport *GetChargeTransportClass() {
        return this->ct;
    }

    void FillEdepEvent(G4double &eDepInScattererPerEvent_, G4double &eDepInSensorPerEvent_, G4double &primaryEnergy_);
    void FillEdepStep(G4int &eventID_, G4double &eDep_, G4double &time_, G4ThreeVector &depPos_, G4int &particleID_, G4int &trackID_, G4int &parentID_);
    void FillEDepInSensor(G4double primaryEnergy_);
    void FillPrimaryPolarization(G4double px_,G4double py_,G4double primaryEnergy_);
    
    /**
     * @brief Set the signal generation to Allpix-squared (true) or built-in simulation (false)
     */
    void SetAllpix(G4bool useAllpix_) {
        this->useAllpix = useAllpix_;
    }

    /**
     * @brief Check the method used to simualte signal generation (true for Allpix-squared, false for built-in simulation)
     * @return Whether Allpix-squared will be used for signal generation simulation
     */
    G4bool GetAllpix() {
        return this->useAllpix;
    }

    /**
     * @brief Generate statistical fluctuation according to the Fano distribution
     * @param electronNum_ Number of electrons generated
     * @return Number of electrons after adding statistical fluctuation
     */
    G4double GenerateFanoNoise(G4double electronNum_) {
        return this->fanoNoiseRand->Gaus(electronNum_, TMath::Sqrt(electronNum_ * this->fanoFactor));
    }

private:
    // Total number of events in the current run
    G4int totalEventNumber;
    // Handler of charge transport process
    ChargeTransport *ct;
    // Output directory
    G4String outputDir;

    // Maximum number of electrons a macro particle can contain
    // Default 10
    G4int electronPerBunch;

    // Use Allpix-squared for signal generation
    G4bool useAllpix = false;

    // ID of the spectrum in the analysis manager
    G4int specID;
    // ID of the polarization histogram in the analysis manager
    G4int polarizationID;
    // ID of the ntuple storing the run data
    G4int runDataID;
    // ID of the ntuple storing the pixel data
    G4int pixelDataID;

    // Variables used to access the pixel data in a event
    // Signals of each pixel
    std::vector<G4double> signal;
    // X coordinate of the pixel centers
    std::vector<G4double> pixelCenterX;
    // Y coordinate of the pixel centers
    std::vector<G4double> pixelCenterY;
    // Z coordinate of the pixel centers
    std::vector<G4double> pixelCenterZ;
    // Time of arrival recorded in each pixel
    std::vector<G4double> pixelTOA;
    // Time-over-threshold recorded in each pixel
    std::vector<G4double> pixelTOT;
    // Whether the current pixel is triggered
    std::vector<G4int> triggered;

    // Variables used to access the energy deposition data used for Allpix-squared simulation
    // Name of the detector in which the energy deposition occurred
    // DO NOT change this name for the sake of keeping the name consistent with the one specified in Allpix-squared config file
    std::string depositDetName = "sensor";
    // Also a stupid auxiliary integer to count the number of words in the detector name
    G4int detNameLen;

    // Random generator for generating the statistical fluctuation (according to Fano's distribution) on the charge collected by each pixel
    TRandom *fanoNoiseRand;
    // Fano factor of the sensor material, as specified in Sammartini el al (2018), DOI: https://doi.org/10.1016/j.nima.2018.09.025
    G4double fanoFactor = 0.24;
    // G4double fanoFactor = 0.3386;
};

#endif
