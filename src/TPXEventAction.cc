//
// ********************************************************************
// * License and Disclaimer                                           *
// *                                                                  *
// * The  Geant4 software  is  copyright of the Copyright Holders  of *
// * the Geant4 Collaboration.  It is provided  under  the terms  and *
// * conditions of the Geant4 Software License,  included in the file *
// * LICENSE and available at  http://cern.ch/geant4/license .  These *
// * include a list of copyright holders.                             *
// *                                                                  *
// * Neither the authors of this software system, nor their employing *
// * institutes,nor the agencies providing financial support for this *
// * work  make  any representation or  warranty, express or implied, *
// * regarding  this  software system or assume any liability for its *
// * use.  Please see the license in the file  LICENSE  and URL above *
// * for the full disclaimer and the limitation of liability.         *
// *                                                                  *
// * This  code  implementation is the result of  the  scientific and *
// * technical work of the GEANT4 collaboration.                      *
// * By using,  copying,  modifying or  distributing the software (or *
// * any work based  on the software)  you  agree  to acknowledge its *
// * use  in  resulting  scientific  publications,  and indicate your *
// * acceptance of all terms of the Geant4 Software license.          *
// ********************************************************************
//
//
/// \file TPXEventAction.cc
/// \brief Implementation of the TPXEventAction class

#include <numeric>
#include <algorithm>

#include "TPXEventAction.hh"

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......

/**
 * @brief Default constructor of TPXEventAction
 * @param runAction Run action object of the current simulation
 */
TPXEventAction::TPXEventAction(TPXRunAction *runAction): G4UserEventAction(), fRunAction(runAction), fEdepInSensor(0) {
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......

/**
 * @brief Destructor of TPXEventAction
 */
TPXEventAction::~TPXEventAction() {
    // delete this->elecHist;
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......

/**
 * @brief Actions to be taken at the beginning of the event, including the initialization of the statistics and storing the info of the initial photon
 * @param event Pointer to the current event
 */
void TPXEventAction::BeginOfEventAction(const G4Event *event) {
    this->eventID = event->GetEventID();
    if (this->eventID % 10 == 0) {
        // Print progress
        G4int totalEventNumber = fRunAction->GetTotalEventNumber();
        G4cout << this->eventID << "/" << totalEventNumber << " events processed" << G4endl;
        std::printf("\033[1A");
    }

    // Initialize all statistics
    this->fEdepInSensor = 0;
    this->chargeDepositVector.clear();
    this->chargeDeposits.clear();
    this->electronPoints.clear();

    // Store the info of the initial photon
    const TPXPrimaryGeneratorAction *generatorAction = static_cast<const TPXPrimaryGeneratorAction*>(G4RunManager::GetRunManager()->GetUserPrimaryGeneratorAction());
    if (generatorAction) {
        const G4ParticleGun *particleGun = generatorAction->GetParticleGun();
        this->primaryEnergy = particleGun->GetParticleEnergy();
        G4ThreeVector Polar = particleGun->GetParticlePolarization();
        this->fRunAction->FillPrimaryPolarization(Polar.x(), Polar.y(), this->primaryEnergy);
    }
}

/**
 * @brief Push the new deposited charge (electron generated by ionization) into the list of deposited charges for the current electron bunch
 * @param charge_ Charge of the new deposited charge, in elementary charges (typically -1 for electrons)
 * @param pos_ Position of the new charge deposition
 */
void TPXEventAction::PushDepositCharge(G4double charge_, ROOT::Math::XYZPoint pos_) {
    ChargeDeposit cd_;
    cd_.SetCharge(charge_);
    cd_.SetPos(pos_);
    cd_.SetEventID(this->eventID);
    this->chargeDeposits.push_back(cd_);
}

/**
 * @brief Fill the deposited charge of the current electron bunch to the list of deposited charge for all electron bunches, in order to generate a new electron bunch to simulate the charge collection process
 */
void TPXEventAction::FillDepositCharge() {
    if (this->chargeDeposits.size() > 0) {
        // Ignore empty deposit vectors
        this->chargeDepositVector.push_back(this->chargeDeposits);
    }
    // Clear the deposited charge of the current bunch for the next bunch to be generated
    this->chargeDeposits.clear();
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......

/**
 * @brief Actions to be taken at the end of the event, including the generation of electron bunches and simulation of charge transport & collection process
 * @param event Pointer to the current event
 */
void TPXEventAction::EndOfEventAction(const G4Event *event) {
    this->eventID = event->GetEventID();
    #ifdef TPXMT
    const TPXRunManager *runManager = static_cast<const TPXRunManager*>(G4MTRunManager::GetMasterRunManager());
    #else
    const TPXRunManager *runManager = static_cast<const TPXRunManager*>(G4RunManager::GetRunManager());
    #endif
    G4bool useAllpix = runManager->GetAllpix();
    G4double energyLowerBound = runManager->GetEnergyLowerBound();

    if (!useAllpix) {
        if (this->fEdepInSensor > energyLowerBound * CLHEP::keV) {
            // Add energy deposition and generate the electron bunches
            this->fRunAction->FillEDepInSensor(this->fEdepInSensor);
            GenerateDepositCharge();
        }
        if (this->chargeDepositVector.size() > 0) {
            Bool_t output = this->eventID == 37; // DEBUG
            // pixel [234, 60], 94.7071 keV
            // Simulate the charge transport and collection process
            fRunAction->GetChargeTransportClass()->ClusterCharge(this->chargeDepositVector);
            fRunAction->GetChargeTransportClass()->ProjectionTransportation(output);
            fRunAction->GetChargeTransportClass()->SingalTransfer();
            fRunAction->GetChargeTransportClass()->Reset();
            this->chargeDepositVector.clear();
        }
    }
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......

/**
 * @brief Push the point where the electron is generated by ionization in the current step into the list of generation points in the current event, which will be used to generate charge bunches
 * @param electronPoint_ Point where the electron is generated
 * @param electronTime_ Generation time of the electron
 * @param electronID_ Track ID of the electron
 */
void TPXEventAction::PushElectron(ROOT::Math::XYZPoint electronPoint_, G4double electronTime_, G4double electronID_) {
    this->electronPoints.push_back(electronPoint_);
    this->electronTimes.push_back(electronTime_);
    this->electronID.push_back(electronID_);
}

/**
 * @brief Generate the charge bunches according to the list of electron generation points and the limitations specified in the run action manager class
 */
void TPXEventAction::GenerateDepositCharge() {
    // Sort the electron data by generation time and track ID
    // The electrons are first split into different tracks according to the track ID, then sorted within the track according to the generation time
    std::vector<G4int> sequence(this->electronPoints.size());
    std::iota(sequence.begin(), sequence.end(), 0);
    std::vector<G4double> &timeTemp = this->electronTimes;
    std::vector<G4double> &trackIDTemp = this->electronID;
    std::sort(sequence.begin(), sequence.end(), [&timeTemp, &trackIDTemp](G4int ind1, G4int ind2) { return trackIDTemp[ind1] == trackIDTemp[ind2]? timeTemp[ind1] < timeTemp[ind2]: trackIDTemp[ind1] < trackIDTemp[ind2]; });
    PushDepositCharge(-1, this->electronPoints[sequence.front()]);
    G4int lastID = this->electronID[sequence.front()];
    for (auto &i : sequence) {
        // Split the electrons into bunches according to the track ID
        if (this->electronID[i] == lastID) {
            PushDepositCharge(-1, this->electronPoints[i]);
        }
        else {
            // If the next electron belongs to a different track, then fill the current points to a electron bunch and the points starting from the next electron point to a new electron bunch
            FillDepositCharge();
            lastID = this->electronID[i];
            PushDepositCharge(-1, this->electronPoints[i]);
        }
        if (this->chargeDeposits.size() >= this->fRunAction->GetEPC()) {
            // Split the electrons into bunches according to the maximum nunber of electrons a bunch can contain
            FillDepositCharge();
        }
    }
    FillDepositCharge();
}
